<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Boxcel デモ（ローカルモジュール版）</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; background:#aee1ff; }
#ui { position:absolute; top:10px; left:10px; z-index:10; display:flex; flex-direction: column; gap:6px; }
#ui button { padding:10px 16px; font-size:18px; border-radius:6px; background: rgba(255,255,255,0.8); border:1px solid #aaa; }
#joystick { position:absolute; bottom:50px; left:50px; width:120px; height:120px; border-radius:50%; background: rgba(200,200,200,0.3); touch-action:none; }
#stick { position:absolute; left:50%; top:50%; width:60px; height:60px; margin-left:-30px; margin-top:-30px; border-radius:50%; background:rgba(100,100,100,0.5); }
</style>
</head>
<body>
<div id="ui">
  <button id="switch">2D / 3D 切替</button>
</div>
<div id="joystick"><div id="stick"></div></div>
<canvas id="gameCanvas"></canvas>

<script type="module">
import * as THREE from './three.module.js';
import { OrbitControls } from './OrbitControls.js';

// === 基本設定 ===
const canvas = document.getElementById('gameCanvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
const scene = new THREE.Scene();
scene.add(new THREE.AmbientLight(0xffffff,1));

const camera2D = new THREE.OrthographicCamera(-200,200,200,-200,0.1,1000);
const camera3D = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,2000);

const controls = new OrbitControls(camera3D, renderer.domElement);
controls.enablePan=false; controls.enableZoom=false;
let mode="2D"; let allowCameraControl=false; controls.enabled=allowCameraControl;

// === Boxcelモデル ===
const boxcel=new THREE.Group();
const clothes=new THREE.Mesh(new THREE.BoxGeometry(20,30,10), new THREE.MeshBasicMaterial({color:0x0033ff})); clothes.position.y=40;
const head=new THREE.Mesh(new THREE.BoxGeometry(20,10,20), new THREE.MeshBasicMaterial({color:0xff6666})); head.position.y=55;
const leftArm=new THREE.Mesh(new THREE.BoxGeometry(5,20,5), new THREE.MeshBasicMaterial({color:0xffaaaa})); leftArm.position.set(-12,45,0);
const rightArm=leftArm.clone(); rightArm.position.x=12;
const leftLeg=new THREE.Mesh(new THREE.BoxGeometry(5,18,5), new THREE.MeshBasicMaterial({color:0xaaaaff})); leftLeg.position.set(-7,21,0);
const rightLeg=leftLeg.clone(); rightLeg.position.x=7;
boxcel.add(clothes,head,leftArm,rightArm,leftLeg,rightLeg);
scene.add(boxcel);

// === 簡易マップ ===
const blockSize=20, walls=[];
const mapData=[
"####################",
"#..................#",
"#......###.........#",
"#..................#",
"#..........#####...#",
"#..................#",
"####################"
];
const ground=new THREE.Mesh(new THREE.PlaneGeometry(mapData[0].length*blockSize,mapData.length*blockSize),
  new THREE.MeshBasicMaterial({color:0x88cc88}));
ground.rotation.x=-Math.PI/2;
scene.add(ground);
function createMap(){
  for(let z=0; z<mapData.length; z++){
    for(let x=0; x<mapData[z].length; x++){
      if(mapData[z][x]==="#"){
        const wall=new THREE.Mesh(new THREE.BoxGeometry(blockSize,blockSize,blockSize), new THREE.MeshBasicMaterial({color:0x777777}));
        wall.position.set((x-mapData[0].length/2)*blockSize, blockSize/2, (z-mapData.length/2)*blockSize);
        scene.add(wall); walls.push(wall);
      }
    }
  }
}
createMap();

// === 移動・ジョイスティック ===
const keys={}, speed=3, joystick=document.getElementById('joystick'), stick=document.getElementById('stick');
let walkCycle=0, joyVector={x:0,y:0}, touchId=null;

function animateWalk(isMoving){
  if(isMoving){ walkCycle+=0.02; const swing=Math.sin(walkCycle)*0.6; leftArm.rotation.x=swing; rightArm.rotation.x=-swing; leftLeg.rotation.x=-swing; rightLeg.rotation.x=swing; }
  else { leftArm.rotation.x=rightArm.rotation.x=leftLeg.rotation.x=rightLeg.rotation.x=0; }
}
function checkCollision(nextPos){ for(const w of walls){ const dx=Math.abs(nextPos.x-w.position.x), dz=Math.abs(nextPos.z-w.position.z); if(dx<blockSize/2+10 && dz<blockSize/2+10) return true; } return false; }

function updateCameras(){
  if(mode==="2D"){ const offset=new THREE.Vector3(150,120,150); camera2D.position.copy(boxcel.position.clone().add(offset)); camera2D.lookAt(boxcel.position.x,boxcel.position.y,boxcel.position.z); }
  else { const offset=new THREE.Vector3(0,120,180); camera3D.position.copy(boxcel.position.clone().add(offset)); camera3D.lookAt(boxcel.position); }
}

function animate(){
  requestAnimationFrame(animate);
  const next=boxcel.position.clone();
  let moving=false, moveDir=null;

  if(keys["ArrowRight"]){ next.x+=speed; moving=true; moveDir="right"; }
  if(keys["ArrowLeft"]){ next.x-=speed; moving=true; moveDir="left"; }
  if(keys["ArrowUp"]){ next.z-=speed; moving=true; moveDir="up"; }
  if(keys["ArrowDown"]){ next.z+=speed; moving=true; moveDir="down"; }

  if(joyVector.x!==0 || joyVector.y!==0){ next.x+=joyVector.x*speed; next.z+=joyVector.y*speed; moving=true; moveDir="joy"; }

  if(!checkCollision(next)) boxcel.position.copy(next);

  if(moveDir){
    if(moveDir==="right") boxcel.rotation.y=0;
    else if(moveDir==="left") boxcel.rotation.y=Math.PI;
    else if(moveDir==="up") boxcel.rotation.y=-Math.PI/2;
    else if(moveDir==="down") boxcel.rotation.y=Math.PI/2;
    else if(moveDir==="joy"){ const angle=Math.atan2(joyVector.x,-joyVector.y); boxcel.rotation.y=angle; }
  }

  animateWalk(moving); updateCameras(); controls.update();
  renderer.render(scene,mode==="2D"?camera2D:camera3D);
}
animate();

// === UI & イベント ===
document.getElementById("switch").addEventListener("click",()=>{
  mode=mode==="2D"?"3D":"2D"; allowCameraControl=(mode==="3D"); controls.enabled=allowCameraControl;
  if(mode==="2D") boxcel.rotation.y=0;
});
window.addEventListener("keydown",e=>keys[e.key]=true);
window.addEventListener("keyup",e=>keys[e.key]=false);

// ジョイスティック
function handleStickMove(touch){
  const rect=joystick.getBoundingClientRect();
  let x=touch.clientX-(rect.left+rect.width/2), y=touch.clientY-(rect.top+rect.height/2);
  const max=rect.width/2; x=Math.max(-max,Math.min(max,x)); y=Math.max(-max,Math.min(max,y));
  stick.style.transform=`translate(${x}px,${y}px)`; joyVector.x=x/max; joyVector.y=y/max;
}
joystick.addEventListener("touchstart",e=>{ const t=e.changedTouches[0]; touchId=t.identifier; handleStickMove(t); });
joystick.addEventListener("touchmove",e=>{ for(const t of e.changedTouches) if(t.identifier===touchId) handleStickMove(t); });
joystick.addEventListener("touchend",e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId){ touchId=null; joyVector.x=joyVector.y=0; stick.style.transform=`translate(0px,0px)`; } } });

window.addEventListener("resize",()=>{ renderer.setSize(window.innerWidth,window.innerHeight); camera3D.aspect=window.innerWidth/window.innerHeight; camera3D.updateProjectionMatrix(); });
</script>
</body>
</html>
