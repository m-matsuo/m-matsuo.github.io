<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Boxcel 2Dクォータービュー＋着せ替えデモ</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; background:#aee1ff; }
  #ui { position:absolute; top:10px; left:10px; z-index:10; }
  #ui button { margin:2px; padding:2px 6px; font-size:12px; }
  #joystick { position:absolute; bottom:50px; left:50px; width:120px; height:120px; border-radius:50%; background: rgba(200,200,200,0.3); touch-action:none; }
  #stick { position:absolute; left:50%; top:50%; width:60px; height:60px; margin-left:-30px; margin-top:-30px; border-radius:50%; background:rgba(100,100,100,0.5); }
</style>
</head>
<body>
<div id="ui">
  <button id="switch">切替 2D/3D</button>
  <div>服:</div>
  <button onclick="changeColor('clothes',0x0033ff)">青</button>
  <button onclick="changeColor('clothes',0xff33ff)">ピンク</button>
  <div>頭:</div>
  <button onclick="changeColor('head',0xff6666)">赤</button>
  <button onclick="changeColor('head',0xffff00)">黄</button>
</div>
<div id="joystick"><div id="stick"></div></div>
<canvas id="gameCanvas"></canvas>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

const canvas = document.getElementById('gameCanvas');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
const clock = new THREE.Clock();

const camera2D = new THREE.OrthographicCamera(-200,200,200,-200,0.1,1000);
const camera3D = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,2000);

let mode="2D";

scene.add(new THREE.AmbientLight(0xffffff,1));

// === 簡易マップ ===
const blockSize=20;
const walls=[];
const mapData=[
"####################",
"#..................#",
"#......###.........#",
"#..................#",
"#..........#####...#",
"#..................#",
"####################"
];
const ground = new THREE.Mesh(new THREE.PlaneGeometry(mapData[0].length*blockSize,mapData.length*blockSize),
  new THREE.MeshBasicMaterial({color:0x88cc88})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

function createMap(){
  for(let z=0;z<mapData.length;z++){
    for(let x=0;x<mapData[z].length;x++){
      if(mapData[z][x]==="#"){
        const wall=new THREE.Mesh(
          new THREE.BoxGeometry(blockSize,blockSize,blockSize),
          new THREE.MeshBasicMaterial({color:0x777777})
        );
        wall.position.set((x-mapData[0].length/2)*blockSize, blockSize/2, (z-mapData.length/2)*blockSize);
        scene.add(wall);
        walls.push(wall);
      }
    }
  }
}
createMap();

// === Boxcelモデル ===
const boxcel = new THREE.Group();
const clothes = new THREE.Mesh(new THREE.BoxGeometry(20,30,10), new THREE.MeshBasicMaterial({color:0x0033ff}));
clothes.position.y=40;
const head = new THREE.Mesh(new THREE.BoxGeometry(20,10,20), new THREE.MeshBasicMaterial({color:0xff6666}));
head.position.y=55;
const leftArm = new THREE.Mesh(new THREE.BoxGeometry(5,20,5), new THREE.MeshBasicMaterial({color:0xffaaaa}));
leftArm.position.set(-12,45,0);
const rightArm = leftArm.clone(); rightArm.position.x=12;
const leftLeg = new THREE.Mesh(new THREE.BoxGeometry(5,18,5), new THREE.MeshBasicMaterial({color:0xaaaaff}));
leftLeg.position.set(-7,21,0);
const rightLeg = leftLeg.clone(); rightLeg.position.x=7;
boxcel.add(clothes,head,leftArm,rightArm,leftLeg,rightLeg);
scene.add(boxcel);

// === 移動・ジョイスティック ===
const keys={};
const speed=3;
let walkCycle=0;
const joystick=document.getElementById('joystick');
const stick=document.getElementById('stick');
let joyVector={x:0,y:0};
let touchId=null;

function animateWalk(isMoving){
  if(isMoving){
    walkCycle+=clock.getDelta()*10;
    const swing=Math.sin(walkCycle)*0.6;
    leftArm.rotation.x=swing;
    rightArm.rotation.x=-swing;
    leftLeg.rotation.x=-swing;
    rightLeg.rotation.x=swing;
  }else{
    leftArm.rotation.x=rightArm.rotation.x=leftLeg.rotation.x=rightLeg.rotation.x=0;
  }
}

function checkCollision(nextPos){
  for(const w of walls){
    const dx=Math.abs(nextPos.x - w.position.x);
    const dz=Math.abs(nextPos.z - w.position.z);
    if(dx<blockSize/2+10 && dz<blockSize/2+10) return true;
  }
  return false;
}

// === カメラ更新 ===
function updateCameras(){
  if(mode==="2D"){
    // 45度クォータービュー
    const offset = new THREE.Vector3(150, 120, 150);
    camera2D.position.copy(boxcel.position.clone().add(offset));
    camera2D.lookAt(boxcel.position.x, boxcel.position.y, boxcel.position.z);
  }else{
    const offset=new THREE.Vector3(0,120,180);
    camera3D.position.copy(boxcel.position.clone().add(offset));
    camera3D.lookAt(boxcel.position);
  }
}

// === アニメーションループ ===
function animate(){
  requestAnimationFrame(animate);
  const next=boxcel.position.clone();
  let moving=false;

  // キーボード
  if(keys["ArrowRight"]) { next.x+=speed; moving=true; }
  if(keys["ArrowLeft"])  { next.x-=speed; moving=true; }
  if(keys["ArrowUp"])    { next.z-=speed; moving=true; }
  if(keys["ArrowDown"])  { next.z+=speed; moving=true; }

  // ジョイスティック
  if(joyVector.x!==0 || joyVector.y!==0){
    next.x+=joyVector.x*speed;
    next.z+=joyVector.y*speed;
    moving=true;
  }

  if(!checkCollision(next)) boxcel.position.copy(next);

  animateWalk(moving);
  updateCameras();
  renderer.render(scene,mode==="2D"?camera2D:camera3D);
}
animate();

// === UI & イベント ===
document.getElementById("switch").addEventListener("click",()=>{mode=mode==="2D"?"3D":"2D";});
window.addEventListener("resize",()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera3D.aspect=window.innerWidth/window.innerHeight; 
  camera3D.updateProjectionMatrix();
});

// キーボード
window.addEventListener("keydown",e=>keys[e.key]=true);
window.addEventListener("keyup",e=>keys[e.key]=false);

// ジョイスティック
function handleStickMove(touch){
  const rect=joystick.getBoundingClientRect();
  let x=touch.clientX-(rect.left+rect.width/2);
  let y=touch.clientY-(rect.top+rect.height/2);
  const max=rect.width/2;
  x=Math.max(-max,Math.min(max,x));
  y=Math.max(-max,Math.min(max,y));
  stick.style.transform=`translate(${x}px,${y}px)`;
  joyVector.x=x/max;
  joyVector.y=y/max;
}
joystick.addEventListener("touchstart",e=>{
  const t=e.changedTouches[0];
  touchId=t.identifier;
  handleStickMove(t);
});
joystick.addEventListener("touchmove",e=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchId) handleStickMove(t);
  }
});
joystick.addEventListener("touchend",e=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchId){
      touchId=null;
      joyVector.x=joyVector.y=0;
      stick.style.transform=`translate(0px,0px)`;
    }
  }
});

// === 着せ替え関数 ===
window.changeColor=(part,color)=>{
  switch(part){
    case "clothes": clothes.material.color.set(color); break;
    case "head": head.material.color.set(color); break;
  }
};

</script>
</body>
</html>
